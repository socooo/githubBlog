<!DOCTYPE html>
<html>
<head>
<title>PIOS_part3</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>虚拟内存</h1>
<hr />
<p>这一章讲解 PIOS 的分页虚拟内存管理。我们会使用 x86 的基于页的地址转换功能给每个进程一个用户级地址空间，分析保护功能剩余的关键部分 -- 阻止进程存取其他进程或内核的地址空间。</p>
<h2>1. 页表的管理</h2>
<h3>设置内核的地址空间</h3>
<p>x86 处理器的分页机制一旦被激活，那么无论处理器运行什么代码，包括内核代码，存取物理内存或 I/O 设备的唯一方法就是通过分页内存管理系统。这意味着要使用分页内存管理，内核必须先要初始化至少一个<strong>页目录/页表</strong>结构体并且在激活分页前将其加载到处理器中。</p>
<p>在 PIOS 里，内核在虚拟地址上存取物理内存和 I/O 设备时应该与它的物理地址一致。因此，需要在激活分页前为内核创建一套恒等映射，让一个虚拟地址映射到与该虚拟地址相同的物理地址上。</p>
<pre><code>void
pmap_init(void)
{
    if (cpu_onboot()) {

        int i = 0;
        int userlo_d = VM_USERLO &gt;&gt; PDXSHIFT;       // userlo_d &lt;= 用户进程使用的地址 &lt; userhi_d 
        int userhi_d = VM_USERHI &gt;&gt; PDXSHIFT;
        // 为内核创建恒等映射。
        for(i; i&lt;userlo_d; i++){
            pmap_bootpdir[i] = i &lt;&lt; PDXSHIFT | PTE_P | PTE_PS | PTE_G | PTE_W;
        }   
        // 用户模式的地址空间初始化为常量 PTE_ZERO
        // PTE_ZERO 不同于 NULL，它指向一个特定页的物理地址，内核会保证这个页的内容永久为 0。
        // 这样做是为了更好的控制页的权限。
        for(i; i&lt;userhi_d; i++){
            pmap_bootpdir[i] = PTE_ZERO;
        }
        // 为内核创建恒等映射。
        for(i; i &lt; NPDENTRIES; i++){
            pmap_bootpdir[i] = i &lt;&lt; PDXSHIFT| PTE_P | PTE_PS | PTE_G | PTE_W;
        }
    }

    // 激活 4MB 页与全局页。
    uint32_t cr4 = rcr4();
    cr4 |= CR4_PSE | CR4_PGE;
    lcr4(cr4);

    // 将引导页目录 pmap_bootpdir 加载到PDBR（页目录基址寄存器，即 cr3）。
    lcr3(mem_phys(pmap_bootpdir));

    // 开启分页。
    uint32_t cr0 = rcr0();
    cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_MP|CR0_TS;
    cr0 &amp;= ~(CR0_EM);
    lcr0(cr0);
}
</code></pre>

<h3>进程间的页目录</h3>
<p>激活了分页机制以后，就需要构建一个映射结构给用户进程提供独立的地址空间。x86 的32位分页系统使用一个两级映射结构：一个页目录代表整个32位地址空间，包含 2^10(1024)个页目录项，每个页目录项指向一个页表的起始地址。一个页表包含了一个 4MB (2^22 byte)地址空间的映射，拥有 2^10（1024）个页表项，每个页表项指向一个页的起始地址。</p>
<pre><code>typedef struct proc {
    spinlock    lock;
    struct proc *parent;
    struct proc *child[PROC_CHILDREN];

    ...

    // 进程的虚拟内存状态。
    pde_t       *pdir;      // 工作页目录。
    pde_t       *rpdir;     // 引用页目录。

    ...

} proc;
</code></pre>

<p>在 PIOS 中，每个进程都有两个页目录：一个工作页目录和一个引用页目录。工作页目录在内核执行该进程是被加载到处理器中，引用页目录的作用会在文件系统里介绍。创建一个新进程时，两个页目录会被初始化为 pmap_bootpdir 的拷贝。</p>
<pre><code>proc *
proc_alloc(proc *p, uint32_t cn)
{
    ...

    cp-&gt;pdir = pmap_newpdir();      // 为进程创建一个工作页目录。
    cp-&gt;rpdir = pmap_newpdir();     // 为进程创建一个引用页目录。

    ...

}


pte_t *
pmap_newpdir(void)
{
    pageinfo *pi = mem_alloc();
    if (pi == NULL)
        return NULL;
    mem_incref(pi);
    pte_t *pdir = mem_pi2ptr(pi);

    // 将引导页目录 pmap_bootpdir 的内容拷贝给新页表。
    assert(sizeof(pmap_bootpdir) == PAGESIZE);
    memmove(pdir, pmap_bootpdir, PAGESIZE);

    return pdir;
}


void gcc_noreturn
proc_run(proc *p)
{
    spinlock_acquire(&amp;p-&gt;lock);
    p-&gt;state = PROC_RUN;
    p-&gt;runcpu = cpu_cur();
    lcr3(mem_phys(p-&gt;pdir));            // 进程切换时需要手动加载该进程的页目录
    spinlock_release(&amp;p-&gt;lock);
    cpu_cur()-&gt;proc = p;
    trap_return(&amp;p-&gt;sv.tf);
}
</code></pre>

<h3>页表管理</h3>
<p>页表的管理代码包含以下三个函数：</p>
<ul>
<li>
<p>pmap_walk（pde_t * pdir，uint32_t va，bool writing）： 查询两级页表，并按内核的需求分配一个页表。这个函数的目的是定位一个页表项（PTE），这个页表项包含了要找的虚拟地址 va。</p>
<p>由于内核将一个新的页目录的所有页目录项初始化为 PTE_ZERO，所以一个新的页目录没有相关的页表。内核是在第一次映射某个地址时才会初始化并分配一个页表给相应的页目录项，这也是 pmap_walk 的一个次要任务。</p>
<p>pmap_walk（）里有 writing 参数，用来指明调用者是“读取”还是“写入”分页结构。如果写入为零（false），并且pmap_walk（）遇到缺少的页表，它只返回NULL，并假设调用者将知道如何继续。如果写入非零（true），那么pmap_walk（）将尝试通过分配和初始化新的页表来“填写”缺少的PDE，只有在mem_alloc（）失败时才返回NULL。当pmap_walk（）分配并将新页表插入到页目录中时，它会将新页表中的所有PTE初始化为PTE_ZERO，但将页表自身插入到页目录中，并设置相应的权限允许处理器在用户或内核模式下读或写新的页表。</p>
<pre><code>pte_t *
pmap_walk(pde_t *pdir, uint32_t va, bool writing)
{
    assert(va &gt;= VM_USERLO &amp;&amp; va &lt; VM_USERHI);
    uint32_t pde_i = PDX(va);
    uint32_t pte_i = PTX(va);
    if(pdir[pde_i] == PTE_ZERO){
        if(!writing)
            return NULL;
        pageinfo* page = mem_alloc();
        if(!page)
            return NULL;
        mem_incref(page);
        // 为页表项(PTE)设置权限。
        pdir[pde_i] = mem_pi2phys(page) | PTE_P | PTE_U | PTE_W | PTE_A;
        int i;
        pte_t* ptable = (pte_t*)PGADDR(pdir[pde_i]);
        for(i = 0; i&lt;NPTENTRIES; i++){
            ptable[i] = PTE_ZERO;
        }
        pte_t* pte_ret = (pte_t*) (&amp;(ptable[pte_i]));
        return pte_ret;
    }
    pte_t* pt_has_ret = (pte_t*) (PGADDR(pdir[pde_i]));
    pte_t* pte_ret = (pte_t*) (&amp;(pt_has_ret[pte_i]));
    return pte_ret;
}
</code></pre>

</li>
<li>
<p>pmap_insert(pde_t *pdir, pageinfo *pi, uint32_t va, int perm)：传入一个指向给定物理页面的 pageinfo 结构的指针，该函数将该页面映射到虚拟地址 va 上，并为 PTE 设置权限 perm 。如果另一个页面已经映射到相同的虚拟地址，则此功能首先会取消旧的映射。</p>
<p>解映射和映射过程都会适当地在pageinfo结构中调整相关联的物理页面的引用计数（pageinfo-&gt;refcount）：增加正在映射的页面的引用计数，并且减少任何未映射的页面的引用计数。如果取消映射后旧页面的引用计数变为0，那么旧页面必须被释放。我们在kern / mem.c中提供了mem_incref（）和mem_decref（）函数，以原子方式增加和减少每页引用计数：这意味着，在多处理器环境中，不必使用自旋锁来维护引用计数的一致性。 mem_decref（）函数在引用计数达到零时也自动调用mem_free（）：这意味着在调用mem_decref（）时，您必须真正完成了该页面的使用，因为另一个处理器可能立即分配并使用这个页面。</p>
<pre><code>pte_t *
pmap_insert(pde_t *pdir, pageinfo *pi, uint32_t va, int perm)
{
    uint32_t pte_i = PTX(va);
    uint32_t pde_i = PDX(va);
    pte_t* pt_base = (pte_t *)PGADDR(pdir[pde_i]);  // PGADDR 会将页表项中的记录的最后三位置零，因为最后三位是权限位。
    uint32_t pte = mem_pi2phys(pi) | perm | PTE_P;
    if((pt_base[pte_i] &amp; 0xfffff000) == (pte &amp; 0xfffff000)){    // 页表项记录的最后三位置零才是给页表项指向的地址。
        pt_base[pte_i] = (pte_t)pte;
        pmap_inval(pdir, va, PAGESIZE);
        return (pte_t*)(&amp;(pt_base[pte_i]));
    }
    if((PGADDR(pdir[pde_i]) != PTE_ZERO) &amp;&amp; (PGADDR(pt_base[pte_i]) != PTE_ZERO)){
        pmap_remove(pdir, PGADDR(va), PAGESIZE);
    }
    pte_t* pte_add = pmap_walk(pdir, va, 1);
    if(!pte_add)
        return NULL;
    pte_add[0] = pte;
    mem_incref(pi);
    return (pte_t*)(pte_add);
}
</code></pre>

</li>
<li>
<p>void pmap_remove（pde_t * pdir，uint32_t va，size_t size）：该函数从虚拟地址空间中删除任意连续的页面映射范围，从va（必须是页对齐）开始，并覆盖 size 大小的地址区域（同样必须是PAGESIZE的倍数）。上述两种功能一次只处理4KB的页面映射，与其不同，该函数会遍历虚拟地址空间，可能会删除该进程中的许多页面映射。此外，如果要删除的地址区域覆盖由一个或多个页表表示的整个4MB区域，则pmap_remove（）不仅会删除那些页表中的所有映射，而且还会在页目录中解映射并释放该页表。</p>
<p>与pmap_insert（）一样，此函数减少所有解映射页面的引用计数，并释放掉引用计数为0的页面。解映射的页表项目处于与新分配的页表中的PTE初始化为相同的状态，即：设置为PTE_ZERO。</p>
<pre><code>void
pmap_remove(pde_t *pdir, uint32_t va, size_t size)
{
    assert(PGOFF(size) == 0);   // must be page-aligned
    assert(va &gt;= VM_USERLO &amp;&amp; va &lt; VM_USERHI);
    assert(size &lt;= VM_USERHI - va);

    uint32_t pde_i = PDX(va);
    uint32_t pte_i = PTX(va);
    int page_account = size/PAGESIZE;
    int remove_pde_no = (page_account+pte_i) / NPTENTRIES;
    int i = 0;
    for(i; i &lt; page_account; i++){
        pte_t* pt_base = (pte_t*)PGADDR(pdir[pde_i + i/NPDENTRIES]);
        if((PGADDR(pdir[pde_i + i/NPDENTRIES]) != PTE_ZERO) &amp;&amp; (PGADDR(pt_base[(pte_i + i) % NPTENTRIES]) != PTE_ZERO)){
            pageinfo* pi = (pageinfo*)mem_phys2pi(PGADDR(pt_base[(pte_i + i)%NPTENTRIES]));
            if(pi){
                mem_decref(pi, mem_free);
                pt_base[(pte_i+i)%NPTENTRIES] = PTE_ZERO;
                pmap_inval(pdir, va, PAGESIZE);     // 刷新 TLB
            }
        }
    }
    if(remove_pde_no &gt; 0){      //  当删除的区域覆盖了 4MB 内容，则要在页目录中删除该页表。
        for(i = 1; i &lt;= remove_pde_no; i++){
            if(i == 1){
                if(pte_i == 0){
                    if(pdir[pde_i] != PTE_ZERO){
                        mem_decref((pageinfo *)mem_phys2pi(PGADDR(pdir[pde_i])), mem_free);
                        pdir[pde_i] = PTE_ZERO;
                    }
                }
            }else{
                if(pdir[pde_i + i -1] != PTE_ZERO){
                    mem_decref((pageinfo *)mem_phys2pi(PGADDR(pdir[pde_i + i -1])), mem_free);
                    pdir[pde_i + i -1] = PTE_ZERO;
                }
            }
        }
    }
}
</code></pre>

</li>
</ul>
<p>由于pmap_insert（）和pmap_remove（）都可以影响处理器已经使用并加载到处理器的翻译后备缓冲区（TLB）中的页面映射，所以如果被修改的地址空间是当前正在运行的进程的地址空间，这些函数还要确保所有受影响的映射都从TLB刷新。</p>
<p>在大多数多处理器操作系统中，像pmap_insert（）和pmap_remove（）这样的操作可能不仅要刷新当前处理器的 TLB，而且还要刷新其他同时运行的处理器的 TLB。此过程称为 TLB shootdown。</p>
<h2>2. ELF可执行文件的加载与运行</h2>
<p>有了设置分页结构的代码后，就可以建立一些分页结构了：在用户地址空间中运行用户模式的“root”进程需要的分页结构，以及从内核链接的可执行映像所需的分页结构。我们提供了一个测试程序user / testvm.c，它们对虚拟内存系统进行了运行和测试，但是您需要将该可执行文件加载到根进程的地址空间中并开始运行。</p>
<p>在探索 xv6 和 PIOS 的引导进程时，已经遇到可执行和可链接格式（ELF）文件：boot / main.c 中的引导加载（bootloader）程序代码已将内核从ELF可执行文件加载到物理内存中。</p>
<p>引导加载内核的程序（bootloader）和内核代码现在需要做的的主要区别是：</p>
<ul>
<li>
<p>物理内存是实际存在的，只需要等待引导加载程序（bootloader）加载某些东西，但 root 进程最初在用户地址空间区域中根本没有加载该程序所需的可访问的内存。在加载程序时，内核必须分配物理页面并将其映射到用户虚拟内存区域。</p>
</li>
<li>
<p>ELF可执行文件可以包含多个段，这些段旨在区分不同的内存访问权限：例如，代码和常量字符串是只读的，对初始化和未初始化数据（bss）是可读可写的。ELF程序头（proghdr）结构的p_flags成员中的标志标识了如何映射一个段。引导加载程序会忽略这些标志，因为没有办法为物理内存分配访问权限。而在第一个用户进程被加载到虚拟内存中时，内核可以并且应该正确设置其内存权限。</p>
</li>
<li>
<p>引导加载程序仅加载由ELF程序头中的p_filesz表示的每个程序段的初始化部分：即包含在ELF文件中的程序段的部分。任何程序段还可以包含一个未初始化的部分，高于p_filesz，但低于Program Header的p_memsz成员指示的内存中段大小。ELF程序加载器应当映射这个未初始化的数据区，但将其内容设置为零。 PIOS的引导加载程序忽略了这个职责，而是让内核自己做到这一点：这就是在kern / init.c开始时 memset（edata，0，end-edata）所做的事情。</p>
</li>
</ul>
<p>ELF头除了描述要加载到存储器中的段，还要指示程序应该开始执行的位置：即程序中第一条指令的用户级别的EIP。除了通过ELF映像描述的方式加载程序本身，内核还需要给根进程创建一个栈。一个一页大小的栈就足够;如果需要的话，根进程可以为自己分配一个更大的栈。用户虚拟内存区域的高端（VM_USERHI之前的最后一页）是根进程栈的合适位置。</p>
<pre><code>proc_root= proc_alloc(NULL, 0);
load_elf(ROOTEXE_START,proc_root);      // 调用加载根进程的函数
proc_root-&gt;sv.tf.fs = CPU_GDT_UDATA | 3;
proc_root-&gt;sv.tf.gs = CPU_GDT_UDATA | 3;    
proc_root-&gt;sv.tf.eip = (uint32_t)(0x40000100);
proc_root-&gt;sv.tf.esp = (uint32_t)(VM_USERHI -1);    // esp 指向用户虚拟内存区域的高端，用作根进程的栈。
proc_root-&gt;sv.tf.eflags = FL_IF;
proc_ready(proc_root);
proc_sched();
</code></pre>

<hr />
<pre><code>void load_elf(char* elf, proc* p){
    uint32_t va, p_va_start, p_va_end;
    proghdr* phd;
    int i, j;
    pte_t* pte;
    elfhdr* elf_load = (elfhdr*)elf;
    phd = (proghdr*)(elf + elf_load-&gt;e_phoff);

    for(i = 0; i &lt; elf_load-&gt;e_phnum; i++){     // 按 program 加载 ELF 文件。
        if(phd-&gt;p_type != 1){
            phd++;
            continue;
        }
        p_va_start = phd-&gt;p_va &amp; (~0xfff);  //  程序文件头的 p_va 字段指出该程序要被加载在哪个地址上。
        p_va_end = (p_va_start + phd-&gt;p_memsz - 1) &amp; ~0xfff;
        for(va = p_va_start; va &lt;= p_va_end; va+=PAGESIZE){     // 为当前程序分配物理内存，并映射到虚拟地址上。
            if(pmap_insert(p-&gt;pdir, mem_alloc(), va, PTE_P | PTE_W | PTE_U) == NULL){
                panic(&quot;no mem in load_elf.\n&quot;);
            };
        }
        phd++;
    }

    phd = (proghdr*)(elf + elf_load-&gt;e_phoff);
    for(i = 0; i &lt; elf_load-&gt;e_phnum; i++){
        if(phd-&gt;p_type != 1){
            phd++;
            continue;
        }

        char* load_va_start = (char*)phd-&gt;p_va;
        char* load_start = elf + phd-&gt;p_offset;
        for(j = 0; j &lt; phd-&gt;p_filesz; j++){     // 将 ELF 程序的内容拷贝到内存里。
            *(load_va_start + j) = *(load_start + j);
        }
        if(phd-&gt;p_memsz &gt; phd-&gt;p_filesz){
            for(j; j &lt; phd-&gt;p_memsz; j++)
                *(load_va_start + j) = 0;       // 未初始化变量等所在的区域初始化为0.
        }
        phd++;
    }

    phd = (proghdr*)(elf + elf_load-&gt;e_phoff);
    for(i = 0; i &lt; elf_load-&gt;e_phnum; i++){
        if(phd-&gt;p_type != 1){
            phd++;
            continue;
        }
        if(phd-&gt;p_flags &amp; ELF_PROG_FLAG_WRITE){
            phd++;
            continue;
        }
        p_va_start = phd-&gt;p_va &amp; (~0xfff);
        p_va_end = (p_va_start + phd-&gt;p_memsz - 1) &amp; ~0xfff;
        for(va = p_va_start; va &lt;= p_va_end; va+=PAGESIZE){     //  为只读区域设置只读权限。
            pte = pmap_walk(p-&gt;pdir,va,1);
            *pte = *pte &amp; (~PTE_W);
        }
    }

    if(pmap_insert(p-&gt;pdir, mem_alloc(), rootexe_stack_addr,SYS_RW| PTE_U | PTE_P | PTE_W) == NULL)     // 为进程栈分配一个物理页并映射到虚拟地址上，其权限为可读写。
        panic(&quot;Has no mem in load_elf assign stack.\n&quot;);
}
</code></pre>

<h2>3. 用户模式下的拷贝</h2>
<p>虚拟内存可以让我们保护内核的状态不受用户级进程的影响，并且也能保护进程彼此之间不会受到影响。我们需要重新考虑内核在系统调用期间如何与用户级代码进行交互。系统调用通常有参数，需要从用户空间传递到内核。 PIOS 系统调用在寄存器中传递简单的参数：lib / syscall.c 中的用户模式系统调用只需在执行INT T_SYSCALL指令之前将参数加载到相应的寄存器中，而 kern / syscall.c 中的内核系统调用处理代码从用户陷阱帧中获取这些参数。</p>
<p>许多系统调用使用了不适合寄存器的参数，比如，sys_cputs 的字符串参数以及 sys_put 和sys_get 里指向 CPUstatus 的指针。对于这样的参数，PIOS 的用户空间里的系统调用只是将参数数据留在用户空间中，给寄存器中传递一个指向这些数据的指针。内核需要从用户空间读取这些参数数据，或者将系统调用结果写入用户空间。如果用户代码传递的是一个无效的指针会怎么样？考虑在系统调用的处理过程中发生以下情况时，会发生什么事：</p>
<ul>
<li>
<p>指针指向用户空间（VM_USERLO和VM_USERHI之间）以外的区域 。</p>
</li>
<li>
<p>给用户空间传递一个指向还未映射的虚拟地址的指针（无访问权限）。</p>
</li>
<li>
<p>给具有写操作的系统调用传递一个指向用户空间的数据区域的指针，例如 sys_get 的 cpustate 参数，但该数据区的一部分或全部已经被映射为只读。</p>
</li>
</ul>
<h3>保护 PIOS 系统调用</h3>
<p>为了解决 PIOS 里这样的安全漏洞，我们需要做两件事情：</p>
<ul>
<li>
<p>每当内核要访问由用户指定并应该指向用户空间的内存区域时，内核必须仔细验证用户指定的整个数据区确实位于用户的地址空间（VM_USERLO和VM_USERHI之间）。</p>
<pre><code>static void checkva(trapframe *utf, uint32_t uva, size_t size)
{
    if(uva &lt; VM_USERLO || uva &gt;= VM_USERHI || uva + size &gt; VM_USERHI){
        systrap(utf, T_PGFLT, 0);
    }
}

static void gcc_noreturn
systrap(trapframe *utf, int trapno, int err)
{
    utf-&gt;trapno = trapno;
    utf-&gt;err = err;
    proc_ret(utf, 0);
}
</code></pre>

</li>
<li>
<p>此外，内核必须预期用户进程可能会将一个指向非法地址的指针传递进来。在这种情况下，处理器在内核中运行时会收到一个陷阱，内核必须清楚这个陷阱是属于用户空间，还是内核空间。</p>
</li>
</ul>
<p>在系统调用的处理过程中，PIOS 遇到由用户引起的内存访问错误时，处理方式与 INT T_SYSCALL 指令本身引起了内存错误时处理方式一致，例如，如果用户发出一个SYS_GET系统调用，要求内核将一个 cpustate 结构写入一个无效或未映射的地址，那么用户进程将会收到一个页错误，如同它直接执行了尝试写入到非法地址的MOV指令一样。这种在系统调用期间处理存储器访问故障的方法只是 PIOS 的方法：同样的情况下，Unix 系统更常见的做法是让系统调用返回带有诸如EFAULT的错误代码。</p>
<h2>4. 使用写时拷贝模式的内存管理</h2>
<p>我们在完全虚拟的地址空间中创建了一个根进程，并采取了适当的措施来保护内核;现在需要实现的是用户进程更改自己的虚拟地址空间，为其子进程设置虚拟地址空间以及与其子进程进行通信的方法。我们不会添加更多的系统调用，而是扩展现有的 GET 和 PUT 系统调用，让调用者能够执行内存管理操作。进程可以通过这样的方式将几个相关操作组合成一个GET或PUT系统调用以提高效率：例如，父进程可以通过一个 PUT 系统调用设置子进程的寄存器状态，并启动运行一个子进程，之后通过一个GET系统调用可以与子进程同步，获取子进程的寄存器状态，并从虚拟地址空间获取一些运行结果。该过程通过设置以下值来进行操作：</p>
<ul>
<li>
<p>SYS_MEMOP中的内存操作代码的位字段。必须是以下值之一：</p>
<ul>
<li>
<p>SYS_ZERO：从目标进程中的一系列虚拟内存中删除所有权限，并将该虚拟内存范围的内容全部替换为零。该操作有效地将给定的存储器范围恢复到进程创建时的“原始”状态。</p>
</li>
<li>
<p>SYS_COPY：将源进程（PUT中的父进程，GET中的子进程）的虚拟内存范围复制到目标进程（PUT中的子进程，GET中的父进程）。为了提高效率，内核最初只复制内存映射，使所有受影响的映射都是只读的，然后只有在用户代码尝试写入复制的页时才根据需要复制实际的页内容。</p>
</li>
<li>
<p>SYS_MERGE（仅适用于GET）：对于给定的虚拟地址，将子进程里与快照不同的地方拷贝到父进程当中。相关内容会在最后一节讲解。</p>
</li>
</ul>
<p>为了简单起见，所有这些存储器操作中，被操作的内存必须从4MB边界上开始，并且大小必须为4MB的倍数。</p>
<p>在进入GET / PUT系统调用时，用户代码在以下寄存器中指定相关的内存范围：</p>
<ul>
<li>
<p>ECX：保存内存区域大小。必须是4MB的倍数。</p>
</li>
<li>
<p>ESI：保存相关进程来源区域（GET的子进程，PUT的父进程）的开始地址。必须是4MB的倍数。</p>
</li>
<li>
<p>EDI：保存相关进程目标区域（GET的父进程，PUT的子进程）的开始地址。必须是4MB的倍数。</p>
<pre><code>switch(flag &amp; SYS_MEMOP){
    case SYS_ZERO:
        assert(size%PTSIZE == 0);
        assert((dest_add)%PTSIZE == 0);
        checkva(tf, dest_add, size);
        pmap_remove(child-&gt;pdir, dest_add, size);
        break;
    case SYS_COPY:

        ...

        if(!pmap_copy(parent-&gt;pdir, source_add, child-&gt;pdir, dest_add, size))   // 对目标区域进行虚拟拷贝（写时拷贝）
            panic(&quot;pmap_copy does not finished.\n&quot;);
        break;
    default:
        break;
    }
</code></pre>

</li>
</ul>
</li>
<li>
<p>SYS_PERM：如果调用进程将该标志设为1，则在执行完 SYS_MEMOP 指定的存储器操作后，内核将为目标内存里的所有页设置权限，权限由 SYS_READ 和 SYS_WRITE 位标出：</p>
<ul>
<li>
<p>只有SYS_PERM：GET / PUT将从目标内存区域中的所有页中删除所有访问权限。这种删除访问不会释放目标内存区域的内容或者归零目标内存区域的内容：实际页面内容与虚拟地址空间中的相关位置保持关联，只是暂时“隐藏”并且不可访问。随后的SYS_PERM操作可以恢复对不可访问页面的访问权限。只有上面的SYS_ZERO操作清除了权限和页面内容。</p>
</li>
<li>
<p>SYS_PERM | SYS_READ：设置目标区域中所有页上的权限，以允许只读访问，而不管这些页的先前权限。如果调用者对未从未使用过的内存区域，或者被填充了 PTE_ZERO 的内存区域执行此操作，则这些页能以只读方式访问。</p>
</li>
<li>
<p>SYS_PERM | SYS_READ | SYS_WRITE：设置目标区域中所有页面的权限，以允许读取和写入权限，无论这些页之前的权限是什么。如果调用者在从未使用过的目标内存区域或被设置为SYS_ZERO的页上执行此操作，则这些页最初虽然被设为零，但可被读取/写入，因此可能被作为“新分配“的虚拟内存使用，相当于Unix或xv6中的sbrk（）。</p>
<pre><code>switch(flag &amp; 0x700){
case SYS_PERM:
    pmap_setperm(child-&gt;pdir, dest_add, size, 0);
    break;
case SYS_PERM | SYS_READ:
    pmap_setperm(child-&gt;pdir, dest_add, size,SYS_READ);
    break;
case SYS_PERM | SYS_READ | SYS_WRITE:
    pmap_setperm(child-&gt;pdir, dest_add, size, SYS_RW);
    break;
default:
    break;
}
</code></pre>

</li>
</ul>
</li>
<li>
<p>SYS_SNAP（仅适用于PUT）：如果在PUT系统调用中将此标志设为1，则在执行上述指定的内存操作和/或权限更改后，内核将该子进程的整个工作地址空间复制到子进程的参考地址空间中（由 proc-&gt; rpdir 表示）。这个标志在最后一节进一步讨论。</p>
</li>
</ul>
<h3>写时复制与名义和实际页权限</h3>
<p>当内核根据SYS_COPY或SYS_SNAP操作的要求执行“批量”虚拟的地址空间复制时，它会使用写时拷贝，当内核执行虚拟拷贝时，对于每个“拷贝”页，内核只是做了：</p>
<ol>
<li>
<p>复制页面映射而不是页本身，源地址和目标地址实际上映射到内存中相同的物理页。</p>
</li>
<li>
<p>增加每个以这种方式共享的页上的引用计数，以跟踪每个页上存在的引用数量。</p>
</li>
<li>
<p>将源和目标映射设置为只读，以防止任一进程直接修改共享页。</p>
</li>
</ol>
<p>进程会尝试写入一个可写的页，但是由于内核的写时拷贝优化，现在这个页是只读的，此时会产生一个页错误，内核需要处理这个页错误，处理的过程需要对进程透明。具体来说，内核分配一个新页，将共享页的内容拷贝到这个新页中，将映射从旧的共享页重定向到这个新的专享页上，并相应地更新页的引用计数（释放一个旧的共享页的引用计数，并在新页中添加一个）。由于新页现在完全由发出页错误的进程所拥有，因此内核现在可以安全地恢复新页上的写入权限。</p>
<p>但是，内核如何在执行虚拟拷贝之前跟踪哪些页面是可写的，哪些页从来不应该是可写的？为了正确区分状态，我们必须给每个页两组权限：名义权限和实际权限。</p>
<pre><code>int 
pmap_copy(pde_t *spdir, uint32_t sva, pde_t *dpdir, uint32_t dva,
        size_t size)        // 写时拷贝
{
    ...

    pte_t* spage;
    pte_t* dpage;
    int page_number = size/PAGESIZE;
    int i = 0;
    for(i; i &lt; page_number; i++){
        if((spage = pmap_walk(spdir, sva, false))){
            if(!(dpage = pmap_walk(dpdir, dva, true)))
                return false;                           // 没有可用内存。
            if((*spage) &amp; PTE_W)    
                *spage |= SYS_WRITE;                    // 若原页面的实际权限为可写，则名义权限为可写。   
            if((*spage) &amp; PTE_P)
                *spage |= SYS_READ;                     // 若原页面的实际权限为可读，则名义权限为可读。
            *spage &amp;= (~PTE_W);                         // 拷贝后，原页面不可读。
            *dpage = *spage;
            uint32_t phy_add = PGADDR(*spage);
            pageinfo* pi = mem_phys2pi(phy_add);        // 目标虚拟地址与源虚拟地址指向同一个物理地址。
            if((PGADDR(*spage)) != PTE_ZERO)
                mem_incref(pi);                         // 添加该物理地址的引用计数。
        }
        sva += PAGESIZE;
        dva += PAGESIZE;
    }
</code></pre>

<p>上述SYS_PERM操作影响的是目标内存区域的名义权限，名义权限有时可能与虚拟内存页的实际页权限不同。虚拟内存的名义页权限是用户级进程指定和查看的页面权限，而实际的页权限是处理器在页表的PTE_P和PTE_W位中看到的“内核内部”的权限条目。页面的名义和实际页面权限通常是相同的，但是当内核对用户模式代码透明地执行写时复制或其他虚拟内存技术时，可能会有所不同。例如，当内核使用写时拷贝来复制其名义权限为 SYS_READ | SYS_WRITE 的内存页，生成的两个页面映射的拷贝继续具有SYS_READ | SYS_WRITE 的名义权限，但内核赋给出这些映射的只有PTE_P（可读）而不是PTE_W（可写）的实际页权限。当其中一个用户进程尝试修改该页时，处理器发生页错误，因为实际的权限不允许写入。而由于内核知道其名义上允许写入，因此它复制共享页面，并提升实际权限使其等于名义权限。</p>
<pre><code>void gcc_noreturn
trap(trapframe *tf)
{
    ...

    if (tf-&gt;trapno == T_PGFLT)
        pmap_pagefault(tf);         // 当内核收到页错误陷阱时，使用pmap_pagefault 来处理。

    ...
}
</code></pre>

<p>如果用户指定的页面上的名义权限只有SYS_READ，那么内核的页面错误处理程序在一个写错误里不会自动提高页面的实际权限。对具有SYS_READ的名义权限的页面进行写操作可能是逻辑软件错误 - 或者至少意味着用户级代码不希望对该页面进行写操作 - 因此与其他异常一样，内核必须将该页面上的写入错误反映给父级进程，而不是试图透明地处理这个错误。</p>
<pre><code>void
pmap_pagefault(trapframe *tf)
{
    // 读取处理器的 CR2 寄存器找到产生错误的线性地址。
    uint32_t fva = rcr2();
    proc* p = proc_cur();
    pageinfo* origin_pi;    

    if((fva &lt; VM_USERLO)  | (fva &gt;= VM_USERHI)){
        return;
    }
    pte_t* fault_pte_point =  pmap_walk(p-&gt;pdir, fva, false);
    uint32_t fault_pte_content = *fault_pte_point;
    if(!fault_pte_point){
        return;
    }
    uint32_t page_flag = fault_pte_content &amp; SYS_WRITE;
    if(!page_flag){
        return;
    }
    if(PGADDR(fault_pte_content) == PTE_ZERO){
        origin_pi = NULL;
    }else{
        origin_pi = mem_phys2pi(PGADDR(fault_pte_content));
    }

    if(page_flag &amp; SYS_WRITE){              // 这是虚拟地址具有写权限而实际权限不能写的情况
        if(origin_pi-&gt;refcount &gt; 1 || (!origin_pi)){        // 页面的引用计数大于1，说明进行过写时拷贝。
            pageinfo* new_page = mem_alloc();
            // 分配一个新页面并将老页面的内容拷贝进去。
            memmove((void*)mem_pi2phys(new_page),(void*)PGADDR(fault_pte_content), PAGESIZE);
            // 将新页面映射到错误进程的虚拟地址上去。
            pmap_insert(p-&gt;pdir, new_page, fva, SYS_RW | PTE_W | PTE_P | PTE_U);
        }
        if(origin_pi-&gt;refcount == 1){
            // 若物理页面的引用计数为1， 则将页面的实际权限设置为可写。
            pte_t* pte = pmap_walk(p-&gt;pdir, fva, false);
            assert(pte != NULL);
            *pte |= PTE_W;
        }
        // 刷新TLB缓存。
        pmap_inval(p-&gt;pdir, PGADDR(fva), PAGESIZE);
        trap_return(tf);
    }
    return;
}
</code></pre>

<p>如果查看 inc/syscall.h 中的 SYS_READ 和 SYS_WRITE 的定义，并将其与 inc/mmu.h 中的PTE定义进行比较，你将注意到SYS_READ和SYS_WRITE都位于页表条目的PTE_AVAIL部分，这部分处理器会忽略，留给软件使用。这种设计是有意的：它使得内核能够在每个页表项的PTE_AVAIL部分中记录每个页的名义权限（由SYS_READ和SYS_WRITE位表示），而不会影响PTE在较低位中的实际页权限或12-31位中表示的物理地址。</p>
<h2>5. 合并虚拟内存</h2>
<p>所有现代 Unix 内核都使用相同的写时拷贝机制来提高 fork() 的效率，在通常情况下进程在 exec() 另一个程序之前只需要写入很少的几个页面。现在，我们将更进一步，提供一种合并机制，将一段时间内独立执行的子进程的结果直接并入到父地址空间里。</p>
<p>回想一下 Unix 的 fork() 对调用 fork() 时的父进程进行一次快照，用这个快照来初始化子进程的状态。然后父子进程各自继续运行，并只能通过很小的（通常为8-bit）返回代码来进行通信，或者通过独立的抽象，如管道、socket、文件系统里的全局共享文件来通信。为了简化 PIOS 的实现，PIOS 使用虚拟内存为进程提供了一个互相通信的方法。</p>
<p>上面实现的GET / PUT系统调用API已经为进程提供了一种“粗粒度”的通信方式：父进程可以使用SYS_PUT | SYS_COPY将自身或其他程序的数据一起复制到子进程的地址空间中，运行子进程，然后使用SYS_GET | SYS_COPY将子进程在其地址空间中留下的结果重新回收到父地址空间中以供进一步使用。这是一个粗粒度的机制，是最小粒度为4MB的地址空间区域的操作。父进程必须确切地知道子进程会将结果存储在哪个区域，以及这些结果要复制到父进程的哪个区域，避免父进程中重要的数据在复制过程中被覆盖掉。如果父进程和子进程密切相关，父进程可能希望让子进程以更精细的粒度生成结果：例如，让子进程计算分散在父进程地址空间中的一些特定的字大小的变量的新值，这些区域可能与不期望被子进程修改的内存混合在一起 - 而父进程本身和其他子进程也会同时在上面做其他操作。提供 PIOS 虚拟内存合并功能的目的就是提供这样的能力。不要害怕这个奇特的名字：它并不比简单的复制拷贝复杂得多，但需要一些解释，因为它可能是一个陌生的概念。</p>
<h3>Merge API</h3>
<p>PIOS 支持虚拟内存合并功能的 API 由前面简要提到的两个操作组成：</p>
<ul>
<li>
<p>SYS_SNAP，仅在PUT系统调用中可用：当调用者指定此标志时，执行任何其他请求的内存及权限管理操作后，内核将对子进程的整个工作用户地址空间（从 VM_USERLO 到 VM_USERHI ）执行一次写时拷贝，放进子进程的参考地址空间（由 proc-&gt; rpdir 表示），这个操作会覆盖子进程的引用地址空间中的任何先前状态。</p>
<pre><code>static void
do_put(trapframe *tf, uint32_t cmd){    

    ...

    switch(flag &amp; SYS_MEMOP){

    ...

    }
    if(flag &amp; SYS_SNAP){
        assert(size%PTSIZE == 0);
        assert((source_add)%PTSIZE == 0);
        assert((dest_add)%PTSIZE == 0);
        checkva(tf, source_add, size);
        checkva(tf, dest_add, size);
        // 将父进程的快照放到子进程的 rpdir 指针里。这个过程只需要调用前面实现的 pmap_copy 写时拷贝函数。
        if(!pmap_copy(child-&gt;pdir, source_add, child-&gt;rpdir, dest_add, size))
            panic(&quot;pmap_copy does not finished.\n&quot;);
    }

    ...

}
</code></pre>

</li>
<li>
<p>SYS_MERGE，仅在GET系统调用中可用：当调用者指定此内存操作时，内核将数据复制到父进程中，如 SYS_COPY所做的类似，不同的是内核只复制一部分子进程的地址空间，这部分地址空间的内容相对于子进程的最后一个参考快照已经发生了改变。这种合并过程以32位机器字的粒度进行：如果子进程的工作地址空间的中特定页面中的某些字与参考空间中的相应字不同，那么内核只将这些字复制到父进程的目标区域里，该页的其他字的值不变。</p>
<pre><code>static void
do_get(trapframe *tf, uint32_t cmd){

    ...

    switch(flag &amp; SYS_MEMOP){

    ...

    }

    if((flag &amp; SYS_MEMOP) == SYS_MERGE){
        assert(size%PTSIZE == 0);
        assert((source_add)%PTSIZE == 0);
        assert((dest_add)%PTSIZE == 0);
        checkva(tf, source_add, size);
        checkva(tf, dest_add, size);
        // 合并虚拟内存。
        pmap_merge(child-&gt;rpdir, child-&gt;pdir, source_add, parent-&gt;pdir, dest_add, size);
    }

    ...
}
</code></pre>

</li>
</ul>
<p>当执行合并时，内核不需要将子进程地址空间的合并部分中的每个页面的每个字与子进程的参考空间中相应的字进行比较。由于孩子的参考空间只是子进程工作空间的写时拷贝，所以如果子进程工作空间里的页面没被修改，那么这些页面仍然和参考空间中的页面相同。因此，对于这样的页面，内核只需要比较页表项。</p>
<pre><code>// 
// Merge differences between a reference snapshot represented by rpdir
// and a source address space spdir into a destination address space dpdir.
//
int
pmap_merge(pde_t *rpdir, pde_t *spdir, uint32_t sva,
        pde_t *dpdir, uint32_t dva, size_t size)
{
    assert(PTOFF(sva) == 0);    // must be 4MB-aligned
    assert(PTOFF(dva) == 0);
    assert(PTOFF(size) == 0);
    assert(sva &gt;= VM_USERLO &amp;&amp; sva &lt; VM_USERHI);
    assert(dva &gt;= VM_USERLO &amp;&amp; dva &lt; VM_USERHI);
    assert(size &lt;= VM_USERHI - sva);
    assert(size &lt;= VM_USERHI - dva);

    uint32_t tmp_va = sva;
    while(tmp_va &lt; sva + size){
        uint32_t rpde = rpdir[PDX(tmp_va)];
        uint32_t spde = spdir[PDX(tmp_va)];
        if(PGADDR(spde) == PTE_ZERO){
            tmp_va += PTSIZE;
            continue;
        }
        pte_t* rpte = pmap_walk(rpdir, tmp_va, false);
        pte_t* spte = pmap_walk(spdir, tmp_va, false);

        //  快照与当前工作空间页表项相同说明页面内容没有改变。
        if(*rpte == *spte){
            tmp_va += PAGESIZE;     
            continue;
        }

        // 工作空间为 PTE_ZERO 时，不改变父进程中的页面内容。
        if(PGADDR(*spte) == PTE_ZERO){
            tmp_va += PAGESIZE;
            continue;
        }

        // 找到改变的位置时，先为父进程分配一个可写的新物理页。
        pte_t* dpte = pmap_walk(dpdir, tmp_va, true);
        if(!dpte)
            panic(&quot;in pmap_merge, has no pte.\n&quot;);
        if(PGADDR(*dpte) == PGADDR(*rpte)){
            uint32_t perm = 0;
            pageinfo* dpage = mem_alloc();
            if(!dpage)
                panic(&quot;in pmap_merge, has no page.\n&quot;);
            mem_incref(dpage);
            mem_pi2phys(dpage);
            memmove((void*)mem_pi2phys(dpage), (void*)PGADDR(*dpte), PAGESIZE);
            if((*dpte &amp; SYS_READ))
                perm = perm | PTE_P | PTE_U;
            if((*dpte &amp; SYS_WRITE))
                perm = perm | PTE_W;
            pmap_insert(dpdir, dpage, tmp_va, perm);
        }
        // 开始合并。
        pmap_mergepage(rpte, spte, dpte, dva);
        tmp_va += PAGESIZE;
    }
    return 1;
}


void
pmap_mergepage(pte_t *rpte, pte_t *spte, pte_t *dpte, uint32_t dva)
{
    uint32_t i = 0;
    // 参考空间相应页面不存在时的情况，只要有内容就进行拷贝。
    if(!rpte || *rpte == PTE_ZERO){
        while(i &lt; PAGESIZE){
            uint32_t cmp_sadd = PGADDR(*spte);
            uint32_t cmp_dadd = PGADDR(*dpte);
            cmp_dadd += i*8;
            cmp_sadd += i*8;
            if(*(uint32_t*)cmp_sadd)
                memmove((void*)cmp_dadd, (void*)cmp_sadd, 4);
            i += 4;
        }
    }else{
        // 参考空间相应页面存在时的情况，只拷贝与参考空间相应页面里不同的地方，按一个字的大小比较。
        while(i &lt; PAGESIZE){
            uint32_t cmp_radd = PGADDR(*rpte);
            uint32_t cmp_sadd = PGADDR(*spte);
            uint32_t cmp_dadd = PGADDR(*dpte);
            cmp_radd += i;
            cmp_dadd += i;
            cmp_sadd += i;
            if(memcmp((void*)cmp_radd,(void*)cmp_sadd, 4))
                memmove((void*)cmp_dadd, (void*)cmp_sadd, 4);
            i += 4;
        }
    }
}
</code></pre>


</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->

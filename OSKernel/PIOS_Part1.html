<!DOCTYPE html>
<html>
<head>
<title>PIOS_Part1</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>系统初始化</h1>
<h2>1. 陷阱处理</h2>
<h3>中断描述符表（IDT）</h3>
<p>在产生陷阱时，内核使用中断描述符表（IDT）来决定如何转移控制权。PIOS有256个进入内核的中断，异常入口点，每个入口点附带一个中断向量。中断向量由中断源确定：不同的设备、错误条件及应用请求产生不同的中断向量。CPU使用中断向量作为进入IDT的索引。处理器会通过IDT中的条目加载以下内容：</p>
<ul>
<li>需要加载到EIP中的值，指向能处理该类型异常的内核代码。</li>
<li>需要加载到代码段（CS）寄存器的值。</li>
</ul>
<h3>陷阱处理器</h3>
<p>当处理器在内核模式下接收到一个陷阱时，首先会将一个陷阱帧压入内核栈，以此来保存某些寄存器的值，这些值在陷阱处里的过程中可能会被修改。然后处理器在IDT中查看陷阱处理器的CS与EIP，并将控制权转交给它。下图展示了一个内核陷阱帧的格式：</p>
<p>+----------------------+ &lt;---- old ESP<br>
| &nbsp;&nbsp;&nbsp;&nbsp;old EFLAGS&nbsp;&nbsp;&nbsp;&nbsp;|     &quot; &nbsp;&nbsp;- 4<br>
|&nbsp;0x00000 | old CS&nbsp;|     &quot;&nbsp;&nbsp; - 8<br>
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old EIP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |     &quot;&nbsp;&nbsp; - 12<br>
+----------------------+ &lt;---- ESP</p>
<p>有些异常的类型会包含一个错误码信息，例如14号页错误异常，包含错误码的陷阱帧格式如下：</p>
<p>+----------------------+ &lt;---- old ESP<br>
| &nbsp;&nbsp;&nbsp;&nbsp;old EFLAGS&nbsp;&nbsp;&nbsp;&nbsp;|     &quot; &nbsp;&nbsp;- 4<br>
|&nbsp;0x00000 | old CS&nbsp;|     &quot;&nbsp;&nbsp; - 8<br>
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old EIP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |     &quot;&nbsp;&nbsp; - 12<br>
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error code&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |     &quot; - 16<br>
+----------------------+ &lt;---- ESP</p>
<p>x86处理器提供了一条特殊的指令：iret，用于从陷阱处理器中返回。执行这条指令需要内核栈如第一张图所示的那样，ESP指向旧的EIP。当处理器执行 iret 指令时，保存的EIP,CS及EFLAGS的内容出栈并进入相应的寄存器中，通过弹出的EIP继续执行接下来的指令。</p>
<h3>设置IDT</h3>
<p>总体的控制流程如下图所示：</p>
<p><img src="http://i.imgur.com/0rUOEmf.png" /></p>
<p>在 trapasm.S 中，每个异常都有自己的handler。</p>
<pre><code>#define TRAPHANDLER(name, num)                      //traphandler with &quot;error code&quot;.
  .globl name;      /* define global symbol for 'name' */   
  .type name, @function;    /* symbol type is function */       
  .align 2;     /* align function definition */     
  name:         /* function starts here */      
  pushl $(num);                         
  jmp _alltraps
</code></pre>

<p>每个handler都要在栈上构造一个结构体 struct trapframe （见inc/trap.h），并调用 trap.c 中的 trap()。</p>
<pre><code>.globl _alltraps
_alltraps:
    pushl %ds
    pushl %es
    pushl %fs
    pushl %gs
    pushal

    movw $(CPU_GDT_KDATA), %ax
    movw %ax, %es
    movw %ax, %ds
    pushl %esp
    call trap
</code></pre>

<p>trap.c 的 trap_init_idt() 使用这些handler的地址来初始化IDT。</p>
<pre><code>
static void
trap_init_idt(void)					//init the IDT with the TRAPHANDLER.
{
	int i;
	extern segdesc gdt[];
	for(i=0; i<=50; i++){
		SETGATE(idt[i], 0, CPU_GDT_KCODE, vectors[i], 0);
	}
	SETGATE(idt[T_BRKPT], 0,CPU_GDT_KCODE, vectors[T_BRKPT], 3);
	SETGATE(idt[T_OFLOW], 0,CPU_GDT_KCODE, vectors[T_OFLOW], 3);
	SETGATE(idt[T_SYSCALL], 0,CPU_GDT_KCODE, vectors[T_SYSCALL], 3);
}

</code></pre>
<p>trap()处理异常/中断或分发给其他处理函数。trap()返回时，trapasm.S 还原处理器状态，并使用 iret 指令从异常状态返回。</p>
<pre><code>.globl  trap_return
.type   trap_return,@function
.p2align 4, 0x90        /* 16-byte alignment, nop filled */
trap_return:
    addl $4, %esp
    movl (%esp), %esp
    popal
    popl %gs
    popl %fs
    popl %es
    popl %ds
    addl $8, %esp
    iret
</code></pre>

<h2>2. 权限等级与受保护的控制转移</h2>
<p>x86处理器提供了多个权限等级或环可以让操作系统用来保护敏感的处理器状态。例如x86限定了 lidt 指令只能在 ring 0 下运行，因此，内核就能阻止应用程序在较低权限等级里执行 lidt 以及其他敏感指令。</p>
<h3>受保护的控制转移的基本原理</h3>
<p>当处理器运行在用户模式（ring 3）中时，如果遇到一个陷阱或系统调用，处理器必须将控制权转移给内核，但此时不能让用户模式的代码随意选择从哪进入内核，或如何进入内核，这对于保护机制来说至关重要。处理器要保证在谨慎的控制条件下进入内核，在x86中，由以下两个机制共同提供保护：</p>
<ul>
<li><strong>中断描述符表（IDT）</strong> 通过 IDT，处理器能确保中断与异常只在特定的、定义好的入口点处进入内核，这些入口点是由内核自己定义的，而不是由产生中断和异常时正在运行的代码决定。</li>
<li><strong>任务状态段（TSS）</strong> 在中断或异常发生时，处理器需要一个地方来保存旧的处理器状态。而这个保存区域必须避免受到非特权用户模式代码的干扰。因此，当一个陷阱或中断使得当前的权限从用户模式切换到内核模式时，同样也要将栈切换到内核的内存中。TSS	结构体指定了这个栈的段选择器与地址。处理器将 SS、ESP、EFLAGS、CS、EIP以及可选的 error code 压入这个新栈，然后从中断描述符中加载 CS 与 EIP，并设置 ESP 与 SS。</li>
</ul>
<p>IDT 和 TSS 联合为内核提供了一套机制，这套机制确保陷阱只能通过调用内核中定义好的入口点（ IDT 中的中断向量）来处理，同时陷阱处理器拥有一个定义好的，受保护的工作空间（ TSS 中的栈指针）。</p>
<h3>例子</h3>
<p>假设处理器正在用户模式下执行代码，并遇到了一个试图除零的指令。</p>
<ol>
<li>
<p>处理器将栈切换到 TSS 的 SS0 和 ESP0 域定义的栈中。这两个域的值分别保留在 CPU<em>GDT</em>KDATA 与 &amp;cpu-&gt;kstackhi 中。</p>
<pre><code>// Set the tss's field, so that when switch the stack, cpu can find where the kenrnel stack set. 
c-&gt;tss.ts_ss0 = CPU_GDT_KDATA;
c-&gt;tss.ts_esp0 = (uintptr_t)(c-&gt;kstackhi);
c-&gt;gdt[CPU_GDT_TSS &gt;&gt; 3] = SEGDESC16(0, STS_T32A, (uintptr_t)(&amp;c-&gt;tss),  sizeof(c-&gt;tss)-1, 0);
ltr(CPU_GDT_TSS);
</code></pre>

</li>
<li>
<p>处理器将下图的陷阱帧压入内核栈。</p>
<pre><code>             +--------------------+ &amp;cpu-&gt;kstackhi
             | 0x00000 | old SS   |     &quot; - 4
             |      old ESP       |     &quot; - 8
             |     old EFLAGS     |     &quot; - 12
             | 0x00000 | old CS   |     &quot; - 16
             |      old EIP       |     &quot; - 20 &lt;---- ESP 
             +--------------------+  &lt;---- ESP
</code></pre>

</li>
<li>
<p>由于现在是在处理除零错误，即x86的0号中断向量，处理器读出IDT第0项，设置 CS:EIP 指向 handler 函数。</p>
</li>
<li>handler 函数获得控制权并处理该异常。</li>
</ol>
<h3>进入用户模式</h3>
<p>x86处理器使用 CS 寄存器的最低两位作为权限等级的标志位。内核与用户状态下的代码段与数据段存放在 gdt （全局描述符表）结构体中。</p>
<pre><code>gdt: {
    // 0x0 - unused (always faults: for trapping NULL far pointers)
    [0] = SEGDESC_NULL,

    // 0x08 - kernel code segment
    [CPU_GDT_KCODE &gt;&gt; 3] = SEGDESC32(1, STA_X | STA_R, 0x0,
                0xffffffff, 0),

    // 0x10 - kernel data segment
    [CPU_GDT_KDATA &gt;&gt; 3] = SEGDESC32(1, STA_W, 0x0,
                0xffffffff, 0),     
    // 0x20 - user data segment
    [CPU_GDT_UDATA &gt;&gt; 3] = SEGDESC32(1, STA_W, 0x0, 
                0xffffffff, 3),
    // 0x18 - user code segment
    [CPU_GDT_UCODE &gt;&gt; 3] = SEGDESC32(1, STA_X|STA_R,0x0,
                0xffffffff, 3 ),

    [CPU_GDT_UDTLS &gt;&gt; 3] = SEGDESC32(1, STA_W, 0x0, 
                0xffffffff, 3),
}
</code></pre>

<p>前面的内容描述了处理器如何通过陷阱离开用户模式，进入内核模式。那么怎样从一开始的内核模式进入到用户模式中呢？很简单，从内核“返回”到用户模式 -- 即使处理器之前从没有进入过内核模式。</p>
<p>当处理器执行 iret 指令时，会从栈中弹出陷阱帧。但处理器并不关心这个栈帧是之前压到栈上的还是从其他地方得到的。因此内核能制造一个栈帧，这个栈帧包含了处理器想要用户模式的状态，然后通过 iret 指令“返回”到用户模式。</p>
<pre><code>.globl  trap_return
.type   trap_return,@function
.p2align 4, 0x90        /* 16-byte alignment, nop filled */
trap_return:
    addl $4, %esp
    movl (%esp), %esp
    popal
    popl %gs
    popl %fs
    popl %es
    popl %ds
    addl $8, %esp
    iret
</code></pre>

<hr />
<pre><code>//构造一个进入用户程序的栈帧
 trapframe tf = {
    gs: CPU_GDT_UDATA | 3,          // 最低2位 “| 3”， 表示权限为 ring 3.
    fs: CPU_GDT_UDATA | 3,
    es: CPU_GDT_UDATA | 3,
    ds: CPU_GDT_UDATA | 3,
    cs: CPU_GDT_UCODE | 3,
    ss: CPU_GDT_UDATA | 3,
    eip: (uint32_t)user,                        //eip指向要执行的用户程序的位置。
    esp: (uint32_t)&amp;user_stack[PAGESIZE],
};
trap_return(&amp;tf);       //调用上面的 trap_return
</code></pre>

<hr />
<pre><code>//用户程序
void
user()
{
    cprintf(&quot;in user()\n&quot;);
    done();
}
</code></pre>

<h2>3.物理页分配</h2>
<h3>分页硬件</h3>
<p>页表是操作系统用来控制地址的机制。它可以让xv6将不同进程的地址空间复用到同一个物理地址，并保护不同进程的内存。由页表提供的间接的等级同样是一种资源，它可以用在很多精妙的技巧中。xv6使用页表主要是为了复用地址空间和保护内存。它也使用一些页表技巧：将相同的（内核）内存映射到数个地址空间，将相同的内存多次映射到同一个地址空间（每个用户表也映射到物理上的内核地址），并用一个未映射的页保护一个用户栈。</p>
<p>x86指令（包括内核和用户）操纵虚拟地址。机器的RAM，或者说是物理内存，由物理地址索引。x86页表硬件通过将每个虚拟地址映射到物理地址来连接两种地址。</p>
<p>一个x86的页表逻辑上是一个含有2^20（1048576）个页表项（PTE）的数组。每个页表项包含一个20位的物理页号（PPN）和一些标志位。分页硬件转译一个虚拟地址的方式是使用它的最高20位从页表中找到相应的PTE，然后用PTE里的PPN替换掉地址的最高20位。分页硬件将低12位从虚拟地址拷贝到转译后的物理地址。因此，操作系统就可以通过页表控制虚拟物理地址间的转换，这种转换是在一个粒度大小为4096字节的块上，这个块就称为页。</p>
<p>如下图，实际的转换分两步。一个页表作为一个两级树存储在物理内存中。树的根是一个4096字节的页目录，包含了1024个PTE，这些PTE引用了页表页。每个页表页是一个含有1024个32位PTE的数组。分页硬件使用一个虚拟地址的最高10位选择一个页目录项，如果存在，分页硬件使用虚拟地址接下来的10位从页表页中选择一个PTE。</p>
<p><img src="http://i.imgur.com/2pdpmv6.png" /></p>
<p>每个PTE都有标志位，这些标志位会告诉分页硬件怎样去联系虚拟地址。PTE_P标明PTE是否存在，如果改位未被设置，则对该页的引用会产生一个错误。PTE_W控制是否能向该页写，PTE_U标明用户程序是否能使用该页。图2-1展示了这些位的使用，相关的结构体定义在mmu.h。</p>
<p>下面说明一些术语。物理内存指DRAM中的存储单元。一个物理内存字节有一个地址，叫做物理地址。指令只使用虚拟地址，这些虚拟地址会被分页硬件转译成物理地址，然后发送给DRAM来读写内存。在目前的讨论层次中没有虚拟内存，只有虚拟地址。</p>
<h3>内存初始化</h3>
<pre><code>void
mem_init(void)
{
    warn(&quot;Assuming we have 1GB of memory!&quot;);
    extmem = 1024*1024*1024 - MEM_EXT;  // assume 1GB total memory

    // The maximum physical address is the top of extended memory.
    mem_max = MEM_EXT + extmem;

    // Compute the total number of physical pages (including I/O holes)
    mem_npage = mem_max / PAGESIZE;

    pageinfo **freetail = &amp;mem_freelist;
    int i;

    //  为 mem_pageinfo 数组分配物理内存，分配的内存需要容纳下 mem_npage 的所有项。
    mem_pageinfo = tmp_pageinfo;
    memset(tmp_pageinfo, 0, (sizeof(pageinfo)*1024*1024*1024)/PAGESIZE);

    // 添加所有的 pageinfo 结构体到 mem_pageinfo 数组中，这个数组代表了所有的可用页。
    for (i = 0; i &lt; mem_npage; i++) {
        // A free page has no references to it.
        mem_pageinfo[i].refcount = 0;

        // 第0页保留给 IDT 和 BIOS 结构体。
        // 第一页保留给启动引导程序代码。
        if(i == 0 || i == 1)    
            continue;

        // [MEM_IO, MEM_EXT) 保留给 I/O 空间。
        if(i &gt;= MEM_IO/PAGESIZE &amp;&amp; i &lt; MEM_EXT/PAGESIZE)
            continue;

        // 为当前运行的 kernel 进程保留内存空间。
        if(i &gt;= ((uint32_t)start)/PAGESIZE &amp;&amp; i &lt;= ((uint32_t)end)/PAGESIZE)
            continue;

        // 将剩余的页面标识为可用页面。
        *freetail = &amp;mem_pageinfo[i];
        freetail = &amp;mem_pageinfo[i].free_next;
    }
    *freetail = NULL;   // null-terminate the freelist

    // ...and remove this when you're ready.
    //panic(&quot;mem_init() not implemented&quot;);

    // Check to make sure the page allocator seems to work correctly.
}
</code></pre>

<h3>内存分配</h3>
<pre><code>pageinfo *
mem_alloc(void)
{
    pageinfo *return_page;
    if(!mem_freelist)
        return NULL;
    spinlock_acquire(mem_spinlock);
    return_page = mem_freelist;
    mem_freelist = mem_freelist-&gt;free_next;
    spinlock_release(mem_spinlock);
    return_page-&gt;free_next = NULL;
    return return_page;
}
</code></pre>

<h3>内存释放</h3>
<pre><code>void
mem_free(pageinfo *pi)
{
    assert(pi-&gt;refcount == 0);
    spinlock_acquire(mem_spinlock);
    pi-&gt;free_next = mem_freelist;
    mem_freelist = pi;
    spinlock_release(mem_spinlock);
}
</code></pre>


</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
